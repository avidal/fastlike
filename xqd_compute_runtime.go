package fastlike

import (
	"crypto/rand"
	"encoding/hex"
	"sync"
)

// sandboxID is a per-process unique identifier (32 lowercase hex digits).
// Generated once on first access and reused for all requests.
var (
	sandboxID     string
	sandboxIDOnce sync.Once
)

// getSandboxID returns the sandbox ID, generating it on first call.
// The sandbox ID is a 32-character lowercase hex string (128-bit UUID without dashes).
func getSandboxID() string {
	sandboxIDOnce.Do(func() {
		// Generate 16 random bytes (128 bits)
		b := make([]byte, 16)
		if _, err := rand.Read(b); err != nil {
			// Fallback to zeros if random fails
			sandboxID = "00000000000000000000000000000000"
			return
		}
		sandboxID = hex.EncodeToString(b)
	})
	return sandboxID
}

// xqd_compute_runtime_get_sandbox_id returns a UUID generated by Fastly for each sandbox.
// This is unique per sandbox but can be reused if a single sandbox handles multiple
// downstream requests. For request-specific identification, use downstream_client_request_id.
//
// Signature: (sandbox_id_out: *mut u8, sandbox_id_max_len: u32, nwritten_out: *mut u32) -> fastly_status
func (i *Instance) xqd_compute_runtime_get_sandbox_id(sandbox_id_out int32, sandbox_id_max_len int32, nwritten_out int32) int32 {
	i.abilog.Printf("compute_runtime_get_sandbox_id: out=%d max_len=%d", sandbox_id_out, sandbox_id_max_len)

	id := getSandboxID()

	// Check buffer size
	if int32(len(id)) > sandbox_id_max_len {
		i.memory.PutUint32(uint32(len(id)), int64(nwritten_out))
		return XqdErrBufferLength
	}

	// Write sandbox ID to guest memory
	nwritten, err := i.memory.WriteAt([]byte(id), int64(sandbox_id_out))
	if err != nil {
		return XqdError
	}

	i.memory.PutUint32(uint32(nwritten), int64(nwritten_out))
	i.abilog.Printf("compute_runtime_get_sandbox_id: id=%s", id)
	return XqdStatusOK
}

// xqd_compute_runtime_get_trace_id returns the trace ID for the current request.
// This is equivalent to FASTLY_TRACE_ID environment variable.
// For local testing, we return the same value as sandbox_id.
//
// Signature: (trace_id_out: *mut u8, trace_id_max_len: u32, nwritten_out: *mut u32) -> fastly_status
func (i *Instance) xqd_compute_runtime_get_trace_id(trace_id_out int32, trace_id_max_len int32, nwritten_out int32) int32 {
	i.abilog.Printf("compute_runtime_get_trace_id: out=%d max_len=%d", trace_id_out, trace_id_max_len)

	// Use sandbox ID as trace ID for local testing
	id := getSandboxID()

	// Check buffer size
	if int32(len(id)) > trace_id_max_len {
		i.memory.PutUint32(uint32(len(id)), int64(nwritten_out))
		return XqdErrBufferLength
	}

	// Write trace ID to guest memory
	nwritten, err := i.memory.WriteAt([]byte(id), int64(trace_id_out))
	if err != nil {
		return XqdError
	}

	i.memory.PutUint32(uint32(nwritten), int64(nwritten_out))
	i.abilog.Printf("compute_runtime_get_trace_id: id=%s", id)
	return XqdStatusOK
}

// xqd_compute_runtime_get_service_version returns the service version number.
// For local testing, this returns "1".
//
// Signature: (version_out: *mut u8, version_max_len: u32, nwritten_out: *mut u32) -> fastly_status
func (i *Instance) xqd_compute_runtime_get_service_version(version_out int32, version_max_len int32, nwritten_out int32) int32 {
	i.abilog.Printf("compute_runtime_get_service_version")

	version := "1"

	// Check buffer size
	if int32(len(version)) > version_max_len {
		i.memory.PutUint32(uint32(len(version)), int64(nwritten_out))
		return XqdErrBufferLength
	}

	// Write version to guest memory
	nwritten, err := i.memory.WriteAt([]byte(version), int64(version_out))
	if err != nil {
		return XqdError
	}

	i.memory.PutUint32(uint32(nwritten), int64(nwritten_out))
	return XqdStatusOK
}

// xqd_compute_runtime_get_hostname returns the hostname of the server.
// For local testing, this returns "localhost".
//
// Signature: (hostname_out: *mut u8, hostname_max_len: u32, nwritten_out: *mut u32) -> fastly_status
func (i *Instance) xqd_compute_runtime_get_hostname(hostname_out int32, hostname_max_len int32, nwritten_out int32) int32 {
	i.abilog.Printf("compute_runtime_get_hostname")

	hostname := "localhost"

	// Check buffer size
	if int32(len(hostname)) > hostname_max_len {
		i.memory.PutUint32(uint32(len(hostname)), int64(nwritten_out))
		return XqdErrBufferLength
	}

	// Write hostname to guest memory
	nwritten, err := i.memory.WriteAt([]byte(hostname), int64(hostname_out))
	if err != nil {
		return XqdError
	}

	i.memory.PutUint32(uint32(nwritten), int64(nwritten_out))
	return XqdStatusOK
}

// xqd_compute_runtime_get_heap_mib returns the current heap usage in mebibytes (2^20 bytes),
// rounded up to the nearest MiB.
//
// Signature: (heap_mib_out: *mut u32) -> fastly_status
func (i *Instance) xqd_compute_runtime_get_heap_mib(heap_mib_out int32) int32 {
	i.abilog.Printf("compute_runtime_get_heap_mib: heap_mib_out=%d", heap_mib_out)

	if i.memory == nil {
		return XqdError
	}

	const mebibyte uint64 = 1024 * 1024
	heapBytes := uint64(i.memory.Len())
	heapMib := (heapBytes + mebibyte - 1) / mebibyte
	if heapMib > uint64(^uint32(0)) {
		heapMib = uint64(^uint32(0))
	}

	i.abilog.Printf("compute_runtime_get_heap_mib: returning %d MiB (%d bytes)", heapMib, heapBytes)
	i.memory.WriteUint32(heap_mib_out, uint32(heapMib))

	return XqdStatusOK
}

// xqd_compute_runtime_get_vcpu_ms returns the amount of active CPU time (in milliseconds)
// that has been consumed by the WebAssembly guest during request processing.
//
// This is NOT wall clock time - it only includes time when the CPU is actively executing
// guest code. Time spent waiting for I/O (e.g., backend requests) is not included.
//
// The function internally tracks time in microseconds for accuracy, but returns milliseconds
// to reduce timing attack surface.
//
// Signature: (vcpu_ms_out: *mut u64) -> fastly_status
func (i *Instance) xqd_compute_runtime_get_vcpu_ms(vcpu_ms_out int32) int32 {
	i.abilog.Printf("compute_runtime_get_vcpu_ms: vcpu_ms_out=%d", vcpu_ms_out)

	// Load accumulated CPU time in microseconds
	microseconds := i.activeCpuTimeUs.Load()

	// Convert to milliseconds
	// We track internally in microseconds because Go's time precision is high,
	// but we return milliseconds to minimize timing attack vectors.
	milliseconds := microseconds / 1000

	i.abilog.Printf("compute_runtime_get_vcpu_ms: returning %d ms (%d us)", milliseconds, microseconds)

	// Write milliseconds to guest memory as u64
	i.memory.WriteUint64(vcpu_ms_out, milliseconds)

	return XqdStatusOK
}
